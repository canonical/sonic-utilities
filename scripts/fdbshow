#!/usr/bin/python
"""
    Script to show MAC/FDB entries learnt in Hardware
    
    usage: fdbshow [-p PORT] [-v VLAN]
    optional arguments:
      -p,  --port              FDB learned on specific port: Ethernet0
      -v,  --vlan              FDB learned on specific Vlan: 1000
  
    Example of the output:
    admin@str~$ fdbshow
      No.    Vlan  MacAddress         Port
    -----  ------  -----------------  ----------
        1    1000  7C:FE:90:80:9F:05  Ethernet20
        2    1000  7C:FE:90:80:9F:10  Ethernet40
        3    1000  7C:FE:90:80:9F:01  Ethernet4
        4    1000  7C:FE:90:80:9F:02  Ethernet8
    Total number of entries 4
    admin@str:~$ fdbshow -p Ethernet4
      No.    Vlan  MacAddress         Port
    -----  ------  -----------------  ---------
        1    1000  7C:FE:90:80:9F:01  Ethernet4
    Total number of entries 1
    admin@str:~$ fdbshow -v 1001
    1001 is not in list

"""

import swsssdk
import argparse
import json
import sys

from tabulate import tabulate
from natsort import natsorted

class FdbShow(object):

    HEADER = ['No.', 'Vlan', 'MacAddress', 'Port']
    FDB_COUNT = 0

    def __init__(self):
        super(FdbShow,self).__init__()
        self.db = swsssdk.SonicV2Connector(host="127.0.0.1")
        self.get_interface_oid_map()
        self.get_bridge_port_oid_map()
        self.fetch_fdb_data()
        return

    
    def get_interface_oid_map(self):
        """
            Get the Interface names from Counters DB
        """
        self.db.connect('COUNTERS_DB')
        self.if_name_map = self.db.get_all('COUNTERS_DB', 'COUNTERS_PORT_NAME_MAP', blocking=True)
        self.if_oid_map = {sai_oid: if_name for if_name, sai_oid in self.if_name_map.items()}


    def get_bridge_port_oid_map(self):
        """
            Get the Bridge port names from ASIC DB
        """
        self.db.connect(self.db.ASIC_DB)
        self.if_br_oid_map = {} 
        br_port_str = self.db.keys('ASIC_DB', "ASIC_STATE:SAI_OBJECT_TYPE_BRIDGE_PORT:*")
        if not br_port_str:
            return
        
        offset = len("ASIC_STATE:SAI_OBJECT_TYPE_BRIDGE_PORT:")
        oid_pfx = len("oid:0x")
        for s in br_port_str:
            br_port_id = s[(offset + oid_pfx):]
            ent = self.db.get_all('ASIC_DB', s, blocking=True)
            port_id = ent[b"SAI_BRIDGE_PORT_ATTR_PORT_ID"][oid_pfx:]
            self.if_br_oid_map[br_port_id] = port_id 


    def fetch_fdb_data(self):
        """
            Fetch FDB entries from ASIC DB. 
            FDB entries are sorted on "VlanID" and stored as a list of tuples
        """
        self.db.connect(self.db.ASIC_DB)
        self.bridge_mac_list = []
        
        fdb_str = self.db.keys('ASIC_DB', "ASIC_STATE:SAI_OBJECT_TYPE_FDB_ENTRY:*")
        if not fdb_str:
            return

        oid_pfx = len("oid:0x")
        for s in fdb_str:
            fdb_entry = s.decode()
            try:
                fdb = json.loads(fdb_entry .split(":", 2)[-1])
            except ValueError as e: 
                print e.message
                continue
           
            ent = self.db.get_all('ASIC_DB', s, blocking=True)
            br_port_id = ent[b"SAI_FDB_ENTRY_ATTR_BRIDGE_PORT_ID"][oid_pfx:]
            try:
                port_id = self.if_br_oid_map[br_port_id]
                if_name = self.if_oid_map[port_id]
            except KeyError as e:
                continue
            
            self.bridge_mac_list.append((int(fdb["vlan"]),) + (fdb["mac"],) + (if_name,))

        return
    
    
    def get_iter_index(self, key_value=0, pos=0):
        """
            Get the starting index of matched entry
        """
        if pos == 0:
            self.bridge_mac_list.sort(key = lambda x: x[pos])
        else:
            self.bridge_mac_list = natsorted(self.bridge_mac_list, key = lambda x: x[pos])

        if key_value == 0:
            return 0

        keys = [r[pos] for r in self.bridge_mac_list]
        try:
            return keys.index(key_value)
        except ValueError as e:
            print e.message


    def display(self, vlan, port):
        """
            Display the FDB entries for specified vlan/port.
            @todo: - PortChannel support
        """
        output = []
        args = {vlan, port}

        if len(args) == 1:
            """
            Display the FDB summary.
            """
            s_index = self.get_iter_index()
            fdb_list = self.bridge_mac_list[s_index:]
        elif None not in args:
            vlan = int(vlan)
            s_index = self.get_iter_index(vlan)
            fdb_list = [fdb for fdb in self.bridge_mac_list[s_index:]
                        if fdb[0] == vlan and fdb[2] == port]
        else:
            #Placeholder added for MAC as None
            arg_list = [vlan, None, port]
            m_index = [idx for idx, val in enumerate(arg_list) if val != None][0]
            if m_index == 0:
                arg_list[m_index] = int(arg_list[m_index])

            s_index = self.get_iter_index(arg_list[m_index], m_index)
            fdb_list = self.bridge_mac_list[s_index:]
            fdb_list = [fdb for fdb in self.bridge_mac_list[s_index:]
                        if fdb[m_index] == arg_list[m_index]]

        for fdb in fdb_list:
            self.FDB_COUNT += 1
            output.append([self.FDB_COUNT, fdb[0], fdb[1], fdb[2]])

        print tabulate(output, self.HEADER)
        print "Total number of entries {0} ".format(self.FDB_COUNT)


def main():
    
    parser = argparse.ArgumentParser(description='Display ASIC FDB entries',
                                     formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-p', '--port', type=str, help='FDB learned on specific port: Ethernet0', default=None)
    parser.add_argument('-v', '--vlan', type=str, help='FDB learned on specific Vlan: 1001', default=None)
    args = parser.parse_args()

    try:
        fdb = FdbShow()
        fdb.display(args.vlan, args.port)
    except Exception as e:
        print e.message
        sys.exit(1)

if __name__ == "__main__":
    main()
