"""
This CLI plugin was auto-generated by using 'sonic-cli-gen' utility, BUT
it was manually modified to meet the PBH HLD requirements.

PBH HLD - https://github.com/Azure/SONiC/pull/773
CLI Auto-generation tool HLD - https://github.com/Azure/SONiC/pull/78
"""

import click
import tabulate
import natsort
import utilities_common.cli as clicommon
from operator import itemgetter
from swsscommon.swsscommon import SonicV2Connector, ConfigDBConnector


def format_attr_value(entry, attr):
    """ Helper that formats attribute to be presented in the table output.

        Args:
            entry (Dict[str, str]): CONFIG DB entry configuration.
            attr (Dict): Attribute metadata.

        Returns:
            str: fomatted attribute value.
    """

    if attr["is-leaf-list"]:
        return "\n".join(entry.get(attr["name"], []))

    return entry.get(attr["name"], "N/A")


def format_group_value(entry, attrs):
    """ Helper that formats grouped attribute to be presented in the table output.

        Args:
            entry (Dict[str, str]): CONFIG DB entry configuration.
            attrs (List[Dict]): Attributes metadata that belongs to the same group.

        Returns:
            str: fomatted group attributes.
    """

    data = []
    for attr in attrs:
        if entry.get(attr["name"]):
            data.append((attr["name"] + ":", format_attr_value(entry, attr)))

    return tabulate.tabulate(data, tablefmt="plain")


@click.group(name='pbh',
             cls=clicommon.AliasedGroup)
def PBH():
    """ Show PBH (Policy based hashing) feature configuration """

    pass


@PBH.group(name="hash-field",
           cls=clicommon.AliasedGroup,
           invoke_without_command=True)
@clicommon.pass_db
def PBH_HASH_FIELD(db):
    """  Show the PBH hash field configuration """

    header = [
        "NAME",
        "FIELD",
        "MASK",
        "SEQUENCE",
        "SYMMETRIC",
    ]

    body = []

    table = db.cfgdb.get_table("PBH_HASH_FIELD")
    for key in natsort.natsorted(table):

        is_pbh_hash_field_symmetric(table, key)

        entry = table[key]

        if not isinstance(key, tuple):
            key = (key,)

        row = [*key] + [
            format_attr_value(
                entry,
                {
                    'name': 'hash_field',
                    'description': 'Configures native hash field for this hash field',
                    'is-leaf-list': False,
                    'is-mandatory': True,
                    'group': ''
                }
            ),
            format_attr_value(
                entry,
                {
                    'name': 'ip_mask',
                    'description': 'Configures IPv4/IPv6 address mask for this hash field',
                    'is-leaf-list': False,
                    'is-mandatory': True,
                    'group': ''
                }
            ),
            format_attr_value(
                entry,
                {
                    'name': 'sequence_id',
                    'description': 'Configures in which order the fields are hashed and defines which fields should be associative',
                    'is-leaf-list': False,
                    'is-mandatory': True,
                    'group': ''
                }
            ),
            format_attr_value(
                entry,
                {
                    'name': 'symmetric',
                    'description': 'symmetric',
                    'is-leaf-list': False,
                    'is-mandatory': False,
                    'group': ''
                }
            ),
        ]

        body.append(row)

    # sorted by 'sequence_id'
    body_sorted = sorted(body, key=lambda e: int(e[3]))
    click.echo(tabulate.tabulate(body_sorted, header))


@PBH.group(name="hash",
           cls=clicommon.AliasedGroup,
           invoke_without_command=True)
@clicommon.pass_db
def PBH_HASH(db):
    """  Show the PBH hash configuration """

    header = [
        "NAME",
        "HASH FIELD",
    ]

    body = []

    table = db.cfgdb.get_table("PBH_HASH")
    for key in natsort.natsorted(table):
        entry = table[key]
        if not isinstance(key, tuple):
            key = (key,)

        row = [*key] + [
            format_attr_value(
                entry,
                {
                    'name': 'hash_field_list',
                    'description': 'The list of hash fields to apply with this hash',
                    'is-leaf-list': True,
                    'is-mandatory': False,
                    'group': ''
                }
            ),
        ]

        body.append(row)

    click.echo(tabulate.tabulate(body, header))


@PBH.group(name="rule",
           cls=clicommon.AliasedGroup,
           invoke_without_command=True)
@clicommon.pass_db
def PBH_RULE(db):
    """  Show the PBH rules configuration """

    header = [
        "TABLE",
        "RULE",
        "PRIORITY",
        "MATCH",
        "HASH",
        "ACTION",
        "COUNTER",
    ]

    body = []

    table = db.cfgdb.get_table("PBH_RULE")
    for key in natsort.natsorted(table):
        entry = table[key]
        if not isinstance(key, tuple):
            key = (key,)

        row = [*key] + [
            format_attr_value(
                entry,
                {
                    'name': 'priority',
                    'description': 'Configures priority for this rule',
                    'is-leaf-list': False,
                    'is-mandatory': True,
                    'group': ''
                }
            ),
            format_group_value(
                entry,
                [
                    {
                        'name': 'gre_key',
                        'description': 'Configures packet match for this rule: GRE key (value/mask)',
                        'is-leaf-list':False,
                        'is-mandatory': False,
                        'group': 'Match'
                    },
                    {
                        'name': 'ip_protocol',
                        'description': 'Configures packet match for this rule: IP protocol (value/mask)',
                        'is-leaf-list': False,
                        'is-mandatory': False,
                        'group': 'Match'
                    },
                    {
                        'name': 'ipv6_next_header',
                        'description': 'Configures packet match for this rule: IPv6 Next header (value/mask)',
                        'is-leaf-list': False,
                        'is-mandatory': False,
                        'group': 'Match'
                    },
                    {
                        'name': 'l4_dst_port',
                        'description': 'Configures packet match for this rule: L4 destination port (value/mask)',
                        'is-leaf-list': False,
                        'is-mandatory': False,
                        'group': 'Match'
                    },
                    {
                        'name': 'inner_ether_type',
                        'description': 'Configures packet match for this rule: inner EtherType (value/mask)',
                        'is-leaf-list': False,
                        'is-mandatory': False,
                        'group': 'Match'
                    },
                ]
            ),
            format_attr_value(
                entry,
                {
                    'name': 'hash',
                    'description':'The hash to apply with this rule',
                    'is-leaf-list': False,
                    'is-mandatory': True,
                    'group': ''}
            ),
            format_attr_value(
                entry,
                {
                    'name': 'packet_action',
                    'description': 'Configures packet action for this rule',
                    'is-leaf-list': False,
                    'is-mandatory': False,
                    'group': ''
                }
            ),
            format_attr_value(
                entry,
                {
                    'name': 'flow_counter',
                    'description': 'Configures packet action for this rule',
                    'is-leaf-list': False,
                    'is-mandatory': False,
                    'group': ''
                }
            ),
        ]

        body.append(row)

    # sorted by 'Priority'
    body_sorted = sorted(body, key=lambda e: int(e[2]), reverse=True)
    click.echo(tabulate.tabulate(body_sorted, header))


@PBH.group(name="table",
           cls=clicommon.AliasedGroup,
           invoke_without_command=True)
@clicommon.pass_db
def PBH_TABLE(db):
    """  Show the PBH table configuration """

    header = [
        "NAME",
        "INTERFACE",
        "DESCRIPTION",
    ]

    body = []

    table = db.cfgdb.get_table("PBH_TABLE")
    for key in natsort.natsorted(table):
        entry = table[key]
        if not isinstance(key, tuple):
            key = (key,)

        row = [*key] + [
            format_attr_value(
                entry,
                {
                    'name': 'interface_list',
                    'description': 'Interfaces to which this table is applied',
                    'is-leaf-list': True,
                    'is-mandatory': False,
                    'group': ''
                }
            ),
            format_attr_value(
                entry,
                {
                    'name': 'description',
                    'description': 'The description of this table',
                    'is-leaf-list': False,
                    'is-mandatory': True,
                    'group': ''
                }
            ),
        ]

        body.append(row)

    click.echo(tabulate.tabulate(body, header))

@PBH.group(name="statistics",
           cls=clicommon.AliasedGroup,
           invoke_without_command=True)
@clicommon.pass_db
def PBH_STATISTICS(db):
    """  Show the PBH counters """

    header = [
        "TABLE",
        "RULE",
        "PACKETS COUNT",
        "BYTES COUNT",
    ]

    body = []

    db_connector = SonicV2Connector(use_unix_socket_path=False)
    db_connector.connect(db_connector.COUNTERS_DB)
    
    pbh_rules = db.cfgdb.get_table("PBH_RULE")

    for table, rule in natsort.natsorted(pbh_rules):
        counter_props = lowercase_keys(db_connector.get_all(db_connector.COUNTERS_DB, "COUNTERS:%s:%s" % (table, rule)))
        if counter_props is not None:
            row = [
                table,
                rule,
                counter_props['packets'],
                counter_props['bytes']
            ]
            body.append(row)

    click.echo(tabulate.tabulate(body, header))


def register(cli):
    cli_node = PBH
    if cli_node.name in cli.commands:
        raise Exception(f"{cli_node.name} already exists in CLI")
    cli.add_command(PBH)


def is_pbh_hash_field_symmetric(table: dict, key_to_check: str):
    """ The 'Symmetric' parameter will have 'Yes' value
        if there are 2 'pbh hash fields' with identical 'sequence_id' value

        Args:
            table: 'PBH_HASH_FIELD' table from CONFIG DB.
            key_to_check: key from the table above to check
    """

    if table[key_to_check].get('symmetric') is None:
        counter = 0

        for key in table:
            if key_to_check != key:
                if table[key_to_check].get('sequence_id') == table[key].get('sequence_id'):
                    counter += 1

        if counter >= 1:
            table[key_to_check]['symmetric'] = 'Yes'
        else:
            table[key_to_check]['symmetric'] = 'No'


def lowercase_keys(dictionary):
    return dict((k.lower(), v) for k, v in dictionary.items()) if dictionary else None

